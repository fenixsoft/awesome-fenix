# 从软件的历史看架构的未来

:::quote 软件架构与硬件算力规模对齐

As long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem.

在没有计算机的时候，也就没有编程问题；当我们有了简单的计算机，编程只是个小问题；而现在我们有了算力规模庞大的计算机，那编程就成为了一个同样巨大的问题了。

:::right

—— [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [Communications of the ACM](https://en.wikipedia.org/wiki/Communications_of_the_ACM), 1972

:::

1972 年，[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) 在为图灵奖颁授典礼所写的[自述文章](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD03xx/EWD340.html)中说到：“在没有计算机的时候，不存在编程问题；当我们有了简单的计算机，编程只是个小问题；而现在我们有了算力规模庞大的计算机，那编程也就成为了一个同样巨大的问题了”。半个世纪前，Dijkstra 已经敏锐洞见了机器算力的提升是编程方法发展的直接牵引，每当人类掌握了更强的算力，便按耐不住想去解决一些以前甚至都不敢去设想的新问题，由此引发软件设计模式的重大变革。

## 历史上的软件危机和契机

计算机刚诞生的年代，硬件规模还很小，甚至程序员的大脑就足够记住数据在几 KB 内存中的布局情况，理解每条指令在电路中的运行逻辑。此时的计算机尽管运算速度比人类快，但并内部没有什么人所不知道的事情；此时的软件开发也没有独立的“架构”可言，软件架构与硬件架构就直接物理对齐的。

随着机器的迅速发展，直接面向硬件进行的软件开发很快触碰到了瓶颈，人脑的生物局限显然无法跟上机器算力前进的步伐，这便是历史上的第一次软件危机的根源——当机器强大到世界上最聪明的人都无法为它编写出合理的程序了，计算机科学还能继续发展吗？第一次软件危机，也是[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)发展的契机，结构化编程扭转了当时直接面向全局数据、满屏 Goto 语句书写[面条式代码](https://en.wikipedia.org/wiki/Spaghetti_code)（Spaghetti Code）的编程思想，强调可独立编写、可重复利用的子过程/局部块的重要性，让软件的每个局部都能够设计专门的算法和数据结构，允许每一位程序员只关注自己所负责的部分，从而在整体上控制住了软件开发的复杂度。此时，软件的架构才开始独立于硬件而存在，软件业开始出现架构师（把控全局）与程序员（聚焦局部）的角色分工。

将软件从整体细分为若干个局部，人类能够以群体配合来共同开发，使得人与计算机又和谐共处了十余年。不过，机器的算力膨胀一直在持续，人类群体的沟通协作能力却终有极限。人毕竟不是可复制的程序，每个人都有自己的理解与认知，如何让各个模块能准确地协同工作成了一场灾难，这就是第二次软件危机的根源。《[人月神话](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)》中有一个几乎每位程序员都听过的案例：IBM 公司为开发的 OS/360 系统投入成本达到了美国的“曼哈顿”原子弹计划的 25%，共有 4000 多个模块，约 100 万条指令，超过 5000 人年，耗资数亿美元，即使如此，结果还是延期交付，在交付使用后的系统中仍发现大量的错误。

:::quote An Introduction to Software Architecture

As the size of software systems increases, the algorithms and data structures of the computation no longer constitute the major design problems. When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.

随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。

:::right

——David Garlan and Mary Shaw, [An Introduction to Software Architecture](https://userweb.cs.txstate.edu/~rp31/papers/intro_softarch.pdf), 1994

:::

渡过第二次软件危机的过程中，面向对象的编程逐步取代了面向过程的结构化编程，成为主流的程序设计思想，这次思想转变宣告“追求最符合人类思维的视角来抽象问题”取代了“追求最符合机器运行特征的算法与数据结构”成为软件架构的第一优先原则，并一直持续沿用至今。这次危机还促使软件工程学的出现， 如何以系统性的、规范化的、可定量的方法去高质量地开发和维护软件成为一门独立的科学。

## 云与分布式渐成为主流

如果说历史上的第一、二次软件危机分别是机器算力规模超过了人类个体的生理极限，超过了人类群体的沟通极限的话。那么在今天，在云计算的时代，数据中心所能提供的算力其实已经逼近了人类协作的工程极限，与此算力相符的程序规模，几乎也到达了无论如何工程措施去优化、无论采用什么管理手段去提升质量，都不可避免仍然会出现意外与异常的程度。如果一个软件系统由大量人员共同研发，并使其分布在云中大量节点同时运行，随着项目规模的增大、时间变长，就肯定会有人疏忽犯错，会有代码携带缺陷，会有电脑宕机崩溃，会有网络堵塞中断，总之，必然会受到墨菲定律的无情打击。

软件架构与硬件算力规模对齐，目前用来适配云与分布式的主流架构是微服务，微服务兴起以后，曾涌现出各类文章去总结、赞美微服务带来的种种好处，诸如简化部署、逻辑拆分更清晰、便于技术异构、易于伸缩拓展应对更高的性能，等等，这些当然都是重要优点。可是，如果不拘泥于特定场景定某个问题，以宏观的角度来看，前面所列这种种好处却都只能算是“锦上添花”、是属于让系统“更好”的动因，肯定比不上系统如何确保“生存”的需求来得本质。笔者看来，从单体到微服务的最根本的推动力，是为了方便某个服务能够顺利地“死去”与“重生”，个体的生死更迭，是关系到整个系统能否可靠续存的关键因素。

举个例子，企业应用中采用单体架构的 Java 系统，其更新、升级都必须要有固定的停机计划，必须在特定的时间窗口内才能按时开始，必须按时结束。如果出现了非计划的宕机，那便是生产事故。但是软件的缺陷不会遵循停机计划来“安排时间出错”，为了应对缺陷与变化，做到不停机的检修，Java 曾经搞出了 OSGi 和 JVMTI Instrumentation 等复杂的 HotSwap 方案，以实现给奔跑中的汽车更换轮胎这种匪夷所思却又无可奈何的需求；而在微服务架构的视角下，所谓系统检修，不过是一次服务滚动更新而已，灰度部署新的程序版本，然后导流、测试、发布。

流水不腐，有老朽，有消亡，有重生，有更迭才是生态运行的合理规律，使用不可靠的部件来构造出一个可靠的系统，是软件架构适配云与分布式算力发展的关键所在。系统中每个局部能拥有独立的生命周期，在整体架构上有物理隔离的设计，那即便采用了不可靠部件，在系统外部观察，整体上仍然有可能表现出稳定健壮的服务能力。

## 从云原生到云不可知

软件架构的演进由人与机器的矛盾所驱动，逐渐与算力规模对齐，我们继续顺着这条线索，思考软件开发的下一个核心矛盾将会是什么？窥探下一个时代的软件架构会具备何种特征？

笔者认为，软件发展的下一个关键矛盾是算力规模超过人应掌握合理知识的极限。经过良好设计的分布式系统，拥有局部的可再生性，在整体上展现出可靠的服务能力。然而，“良好地设计”一个分布式系统很不容易，今天无限火热的云原生、微服务、不可变基础设施、弹性计算、服务网格、无服务器架构、高低零代码，等等，背后都能展开成一整套成体系的开发或者架构方法。这些新的技术在为人们解决了更复杂软件问题的同时，也正在把编程这件事情本身推向更高层次的复杂度。一名刚刚走出校园的大学生，要消化完所用编程语言的核心细节，要掌握领域中常用的类库、框架和工具，要理解分布式系统的服务弹性、容错、限流等设计技巧，要接触容器、云原生、函数计算等运行架构层面的原理，耗费上十年的时间都毫不奇怪。

在哲学里，曾经严肃研讨过“知识膨胀”的问题，说的是人类科学的前沿在不断拓展，触及到前沿所需的基础知识也不断增加，是否会陷入后来者终其一生都无法攒下足够基础，导致人类知识陷入止步不前的危机之中。在计算机科学里，知识膨胀就表现为从毕业到“[35 岁退休](https://www.infoq.cn/article/fhzjrzzmzvcee17rcrm0)”（梗）之前，很多程序员恐怕都不具备设计分布式架构所需的全面知识。

云与分布式时代，软件知识又到了该“打个结”的时刻，我们要设法把某些重要但困难的知识标准化并下沉。如同今天大多数程序开发都不再关注寄存器、信号、中断等与机器底层的细节，也不会太关注操作系统内存页/段、执行调度器、I/O 原理等操作系统底层的细节，等云数据中心彻底成熟，变成主流的程序部署环境后，云与分布式的复杂细节也一定会被隐藏起来。

未来软件如何使用云服务，如何进行分布式部署，现阶段还很难有定论，但其中的[非功能属性](https://en.wikipedia.org/wiki/DFX)应该会逐渐外置，而不应该像现在这样，在开发阶段镌刻定型于程序代码之中。软件是以单体还是以分布式运行，需要提供怎样的 SLA，具体与哪些技术组件进行协作，通讯中是否要容错限流，等等，都不必在开发期就锁定，也不必由业务开发人员去关注，他们只处理那些承载系统业务价值的功能属性。这种外挂式的软件架构风格，如同你要上战场便穿上军装，要游泳便穿上泳衣，去舞会便穿上礼服，不同的装备让人能适应不同的场景。而那些“可穿戴”的装备，都是由专业厂商设计，有质量保证，不需要每位编写代码的程序员都知道它们应该如何工作。

逐渐开始成熟的 Service Mesh 就展露出一些这方面的特征，Sidecar 以流量劫持的方式，能够为程序间的网络通讯额外附加上连接稳定性（如重试、熔断）、安全性（如鉴权、双向通讯加密）、可管理性和可观测性，既不需要专门去编码，也不依赖某款语言或者框架的预置功能。不过，Service Mesh 仅能满足与服务通讯能力相关的治理，而软件设计所需的能力并不止通讯这一项，开发者要依赖多种提供不同能力的运行时来搭建软件，譬如高级语言虚拟机提供执行能力、消息队列提供 Pub/Sub 通知能力、容器编排系统提供生命周期管理能力，等等。开发者使用这些能力时，也面临与通讯一样的治理需求。ShardingSphere 的作者张亮曾经[在 InfoQ 撰文](https://www.infoq.cn/article/database-mesh-sharding-jdbc)，提出过 Database Mesh 的设想，将数据库发现、访问路由、数据分片、读写分离、负载均衡等也交给 Sidecar 来实现。既然 Service 和 Database 可以 Mesh 化，那 Cache Mesh、MessageQueue Mesh、Storage Mesh……都有出现的理由。更进一步，分布式中那些复杂的处理技巧，如并行、并发、状态、共识，等等，是不是也可以从程序代码中独立出去，由 Sidecar 引导至合适的、不特定的组件中妥善处理？最后，一旦云计算服务提供商的技术货架中大多数组件都被 Mesh 化，那 Serverless 的"后端即服务"（BaaS）自然便有了最广泛的基础。此时，云数据中心就像是一套无限算力的机器与标准化的操作系统，从此无需再关心程序在哪里执行（FaaS），也不再关心程序有何依赖（BaaS），云原生顺利步入到[云不可知](https://www.avenga.com/magazine/cloud-agnostic-vs-cloud-native/)（Cloud Agnostic）的阶段，对云与分布式架构“打个结”的动作便可以宣告完成。

虽然迄今为止，上述设想距离现实还很远，理论不够成熟，能在生产环境中使用的多运行时框架仍处于十分早期阶段（如较知名的微软 [DAPR](https://dapr.io/) 刚刚在上周进入 [CNCF](https://www.cncf.io/) 孵化）。但笔者愿意相信这是未来架构演进的一个重要方向，必须把复杂的问题尽量关进笼子，由专业人员去看护，才能让普通程序员更好参与软件开发，甚至通过低/零代码工具的支持，让那些没有太多编程知识，但是领域知识丰富的业务专家，也能够独立设计出优秀的软件。

## 软件，架构与人

第一次软件危机在 1950 年代末期初现端倪，结构化编程思想在 1970 年才被正式提出；第二次软件危机（连同"软件危机"这个概念）是在 1970 年[北约 NATO 会议](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences)上被定义的，要一直到 1990 年代面向对象的设计方法成为主流，以及 Scrum、XP 等软件工程方法被提出后，这次危机才算是画上句号。从 2010 年左右开始兴起的云计算是程序的运行基础继“大型计算机”转到“客户端-服务器”之后的[又一场巨变](https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97#%E6%B2%BF%E9%9D%A9)，与前两次软件危机带来的变革契机一样，已有的软件架构和开发方法，一定也会在以十年计数的时间段内逐渐被颠覆，今天你我所谈的云原生、微服务等话题，也仅仅是这次变革浪潮的开端。

与技术变革相伴的，是行业以及对程序员这个群体的影响。第一次软件危机的时代，世界上最聪明的科学家/工程学家在开发软件；第二次软件危机的时代，社会中的高智商高学历的精英群体在开发软件；云与分布式的时代，作为开发者的我们受到冲击吗？未来的软件开发对普通程序员应该会是更友善更简单的，但是对普通程序员友善与简单的背后，预示着未来的信息技术行业很可能会出现“阶级分层”的现象，由于更先进的软件架构已经允许更平庸的开发者也同样能写出可运行、可用于生产的软件产品，同时又对精英开发者提出更多、更复杂的技术要求，长此以往，在开发者群体中会出现比现在还要显著的[马太效应](https://en.wikipedia.org/wiki/Matthew_effect)，迫使开发者的分层，从如今所有开发者都普遍被认为是“高智商群体”的状态，转变为大部分工业化软件生产工人加上小部分软件设计专家的金字塔结构，今天我们自嘲的 CRUD Boy，随着软件产业成熟，势必会越来越普遍，软件业终究是会出现“蓝领工人”这一角色。

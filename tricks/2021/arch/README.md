# 从软件的历史看架构的未来

:::quote 软件架构与硬件算力规模对齐

As long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem.

在没有计算机的时候，也就没有编程问题；当我们有了简单的计算机，编程只是个小问题；而现在我们有了算力规模庞大的计算机，那编程就成为了一个同样巨大的问题了。

:::right

—— [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra), [Communications of the ACM](https://en.wikipedia.org/wiki/Communications_of_the_ACM), 1972

:::

1972年，[Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra)在图灵奖颁授现场发表的获奖感言中说到：“在没有计算机的时候，不存在编程问题；当我们有了简单的计算机，编程只是个小问题；而现在我们有了算力规模庞大的计算机，那编程也就成为了一个同样巨大的问题了”。半个世纪前Dijkstra就已经敏锐洞见了机器算力的提升是软件发展的直接牵引，每当人类掌握了更强的算力，便按耐不住想去解决一些以前甚至都不敢去设想的新问题。

## 历史上的软件危机和契机

计算机刚诞生的年代，硬件的算力规模还很小，甚至程序员的大脑就足够记住数据在几KB内存中的分布细节，记住每项操作在电路中的运行逻辑。此时的计算机尽管运算速度比人类快，但并内部没有什么事情人所不知道的；此时的软件开发也并没有独立的“架构”可言，软件架构与硬件架构直接物理对齐。

随着机器的迅速发展，直接面向硬件架构来进行开发很快触碰到瓶颈，人脑的生物局限显然无法跟上机器算力迅捷的前进步伐，这便是历史上的第一次软件危机的根源——当世界上最聪明的人都无法为机器编写出合理的程序了，计算机科学还能继续发展吗？第一次软件危机发生，是高级语言和[结构化编程](https://en.wikipedia.org/wiki/Structured_programming)发展的契机，高级语言屏蔽大多数硬件细节，获得了相对良好的抽象能力与可移植性，结构化编程扭转了面向全局数据的开发方式，强化了可独立编写、可重复利用的子过程的思想，让软件的每个局部都可以设计独立的算法和数据结构，从而在整体上控制住了软件开发的复杂度，允许每一位程序员只关注自己所负责的部分。此时，软件的架构才开始独立于硬件而存在，软件业开始出现架构师（把控全局）与程序员（聚焦局部）的角色分工。

通过将软件从整体拆分为多个局部个体，人类能够以群体配合来共同开发一个软件，令人类与计算机又和谐共处了十余年，可是机器的算力规模能持续膨胀，人类群体的协作沟通能力却终有极限。人毕竟不是可复制的程序，每个人都有自己的理解与认知，如何让每个模块都能准确的协同工作成了一场灾难，这就是第二次软件危机。《人月神话》中有一个几乎每位程序员都读过的案例：IBM公司为开发的OS/360系统投入成本达到了美国的“曼哈顿”原子弹计划的25%，共有4000多个模块，约100万条指令，超过5000人年，耗资数亿美元，结果还是延期交付，在交付使用后的系统中仍发现大量的错误。

:::quote An Introduction to Software Architecture

As the size of software systems increases, the algorithms and data structures of the computation no longer constitute the major design problems. When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.

随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。

:::right

——David Garlan and Mary Shaw, [An Introduction to Software Architecture](https://userweb.cs.txstate.edu/~rp31/papers/intro_softarch.pdf), 1994

:::

应对第二次软件危机的过程中，面向对象的编程逐步取代了面向过程的结构化编程成为主流的设计思想，这次思想转变宣告追求最符合人类思维的视角来抽象问题取代了追求最符合机器运行特征的算法与数据结构成为软件架构的最优先原则，并一直持续至今。这次危机还促使软件工程学的出现， 如何以系统性的、规范化的、可定量的方法去高质量地开发和维护软件成为一门独立的科学。

## 云与分布式渐成为主流

如果说历史上的第一、二次软件危机分别是机器算力规模超过了人类个体的生理极限，超过了人类群体的沟通极限的话。那么在今天，在云计算的时代，数据中心所能提供的算力其实也已经逼近了人类协作的工程极限，与此算力相符的程序规模，几乎也到达了无论如何优化工程措施、无论采用什么管理手段去提升质量，都不可能避免仍然会出现错误的程度。越来越多程序员认可，只要时间足够长，环境足够复杂，就肯定会有人疏忽犯错，会有代码携带缺陷，会有电脑宕机崩溃，会有网络堵塞中断……如果一项工程需要大量的人员共同去研发某个大规模的软件产品，并使其分布在网络中大量的服务器节点中同时运行，随着项目规模的增大、运作时间变长，其必然会受到墨菲定律的无情打击。

目前，匹配数据中心算力规模的程序多是以微服务为主要架构形式的分布式系统，微服务兴起以后，曾涌现出各类文章去总结、赞美微服务带来的种种好处，诸如简化部署、逻辑拆分更清晰、便于技术异构、易于伸缩拓展应对更高的性能等等，这些当然都是重要优点。可是，如果不拘泥于特定场景定某个问题，以宏观的角度来看，前面所列这种种好处却都只能算是“锦上添花”、是属于让系统“活得更好”的动因，肯定比不上系统如何“确保生存”的需求来得关键本质。笔者看来，这次架构演进最重要的驱动力，或者说从单体到微服务的最根本的驱动力，就是为了方便某个服务能够顺利地“死去”与“重生”，个体服务的生死更迭，是关系到整个系统能否可靠续存的关键因素。

举个例子，以前企业中应用的单体架构 Java 系统，其更新、升级都必须要有固定的停机计划，必须在特定的时间窗口内才能按时开始，必须按时结束。如果出现了非计划的宕机，那便是生产事故。但是软件的缺陷不会遵循停机计划来“安排时间出错”，为了应对缺陷与变化，做到不停机地检修，Java 曾经搞出了 OSGi 和 JVMTI Instrumentation 等这样复杂的 HotSwap 方案，以实现给奔跑中的汽车更换轮胎这种匪夷所思却又无可奈何的需求；而在微服务架构的视角下，所谓系统检修，不过只是一次在线服务更新而已，部分灰度升级新的软件版本，有条不紊地导流、测试、做金丝雀发布，一切都是显得如此理寻常。

流水不腐，有老朽，有消亡，有重生，有更迭才是生态运行的合理规律，是使用不可靠的部件来构造出一个可靠的系统的关键所在。系统中每个局部能拥有独立的生命周期，在整体架构上有物理隔离的设计，那即便采用了不可靠部件，在系统外部观察，整体上仍然有可能表现出稳定健壮的服务能力。

## 未来：云不可知，道不可名

软件架构的演进由人与机器的矛盾所驱动，逐渐与算力规模对齐，我们不妨顺着这个思路，思考软件开发的下一个核心矛盾将会是什么？以此窥探下一个时代的软件架构会具备何种特征？

笔者认为软件开发的下一个核心矛盾是算力规模超过人应掌握合理知识的极限。经过良好设计的分布式系统，拥有局部的可再生性，在整体上展现出可靠的服务能力。然而，“良好地设计”一个分布式系统很不容易，今天无限火热的云原生、微服务、不可变基础设施、弹性计算、服务网格、无服务器架构、高低零代码，等等，背后都能展开成一整套成体系的开发或者架构方法。这些新的技术在为人们解决了更复杂软件问题的同时，也正在把编程这件事情本身推向更高层次的复杂度。一名刚刚走出校园的大学生，要消化完若干编程语言的核心细节，要掌握领域中常用的类库、框架和工具，要理解分布式系统的服务弹性、容错、限流等设计技巧，要接触容器、云原生、函数计算等运行架构层面的原理，耗费上十年的时间都毫不奇怪。

在哲学里，曾经严肃研讨过“知识膨胀”的问题，说的是人类科学的前沿在不断拓展，触及到前沿所需的基础知识也不断增加，是否会陷入后来者终其一生都无法攒下足够基础，导致人类知识陷入止步不前的危机之中。在计算机科学里，知识膨胀通常表现为从毕业到“[35岁退休](https://www.infoq.cn/article/fhzjrzzmzvcee17rcrm0)”（梗）之前，多数程序员恐怕都不具备设计分布式架构所需的全面知识。

云与分布式时代的软件知识又到了该“打个结”的时候，如同今天大多数程序开发都不需要关注寄存器、信号、中断等与机器底层的细节，也不需要关注操作系统内存页表、调度器、底层I/O原理等操作系统底层的细节，等到云计算彻底成为主流的程序部署环境后，云与分布式的复杂细节也会被隐藏起来。

未来软件如何使用云服务，如何进行分布式，其中的[非功能属性](https://en.wikipedia.org/wiki/DFX)将会逐渐外置，而不应该像现在这样，在开发阶段镌刻定型于程序代码之中。软件是以单体还是以分布式运行，需要提供怎样的SLA，具体与哪些技术组件进行协作，通讯中是否要容错限流，等等，都不必在开发期就锁定起来，也不必由业务开发人员去关心，他们只处理那些承载系统业务价值的功能属性。这种外挂式的软件架构就如同是人上战场便穿上军装，要游泳便穿上泳衣，去舞会便穿上礼服，不同的装备让人能适应不同的场景。而那些“可穿戴”的装备，都是由专业厂商设计，有质量保证，不需要每位编写代码的程序员都知道它们应该如何工作。

已经逐渐开始成熟的Service Mesh就展露出一些这方面的特征，Sidecar以流量劫持的方式，能够为程序间的网络通讯额外附加上连接稳定性（如重试、熔断）、安全性（如鉴权、双向通讯加密）、可管理性和可观测性，既不需要专门去编码，也不依赖某款语言或者框架的预置功能。不过Service Mesh的仅能够处理与服务通讯能力相关的治理，而软件设计所需的能力并不止通讯这一项，开发者会依赖多种提供不同能力的运行时，譬如高级语言虚拟机提供执行能力、消息队列提供Pub/Sub通知能力、容器编排系统提供生命周期管理能力，等等来搭建软件。开发者使用这些能力时，也面临与通讯一样的治理需求，譬如ShardingSphere的作者曾经[在InfoQ发文](https://www.infoq.cn/article/database-mesh-sharding-jdbc)，提出了Database Mesh的方案，将数据库发现、访问路由、数据分片、读写分离、负载均衡等都交给Sidecar来实现。既然Service、Database可以Mesh化，那Cache Mesh、MessageQueue Mesh、Storage Mesh都该顺理成章地被发明出来。更进一步，分布式中那些复杂的处理技巧，如并发处理、状态管理等功能，也可以从程序中独立出去，由Sidecar引导至合适的、不特定的组件中进行妥善处理。最后，当云计算服务提供商的技术货架中所有的组件都被Mesh化，那Serverless的BaaS就有了广泛的后端基础设施，云原生也就顺理成章地步入到[云不可知](https://www.avenga.com/magazine/cloud-agnostic-vs-cloud-native/)（Cloud Agnostic）的时代，对云与分布式架构“打个结”的动作便可以宣告完成。

尽管迄今为止，可以在生产环境中使用的多运行时框架还并不多见，较知名的微软DAPR。但这是未来架构演进的一个重要方向，只有把那些复杂的问题关进笼子，从软件开发中移开，普通程序员参与，以后甚至通过低代码、无代码的支持，让那些基本不具备程序设计知识，但是具有丰富业务知识的专家，也可能设计出优秀的软件，而非仅单纯的搭积木。

## 软件，架构与人

第一次软件危机在1950年代末期初现端倪，而结构化编程思想在1969年被正式提出；第二次软件危机，连同"软件危机"这个概念，也是在1969年[北约NATO会议](https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences)上被定义的，而要一直到1990年代面向对象的设计方法成为主流，以及Scrum、XP等软件工程方法被提出后才算是画上句号。从2010年左右开始兴起的云计算是程序的运行硬件继大型计算机到客户端-服务器之后的又一次巨变，与前两次软件危机带来的巨大变革一样，我们的软件架构和开发方法，也会发生同样以十年计数的巨大改变，今天提的云原生、微服务都仅仅是这次浪潮的开端，相比起技术的变化，我们更关心对人，对作为开发者的我们，会产生什么影响？

笔者认为，未来的软件开发对普通程序员会是更友善更简单的，甚至能在低代码/零代码的帮助下达到一定意义上“全民编程”的效果。但是对普通程序员友善与简单的背后，预示着未来的信息技术行业很可能也会出现“阶级分层”的现象，由于更先进的软件架构已经允许更平庸的开发者也同样能写出可运行、可用于生产的软件产品，同时又对精英开发者提出更多、更复杂的技术要求，长此以往，在开发者群体中会出现比现在还要显著的[马太效应](https://en.wikipedia.org/wiki/Matthew_effect)，导致开发者的分层，从如今所有开发者都普遍被认为是“高智商人群”的状态，转变为大部分工业化软件生产工人加上小部分软件设计专家的金字塔结构，以后分布式软件的开发，会由少量的负责架构和质量属性的专家，与大量的负责功能属性的业务程序员去协作完成。如同已经发展数千年完全成熟的建筑业，设计师负责绘制图纸，建筑工人根据图纸负责填充水泥钢筋，搭建完整个建筑。


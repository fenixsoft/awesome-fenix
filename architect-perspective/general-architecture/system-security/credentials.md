# 凭证

::: tip 凭证（Credentials）

系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？

:::

在前面介绍OAuth2的内容中，每一种授权模式的最终目标都是拿到访问令牌，但从未涉及过拿回来的令牌应该长什么样子。反而还挖了一些坑没有填（为何说OAuth2的一个主要缺陷是令牌难以主动失效）。这节讨论的主角是令牌，同时，还会讨论如果不使用OAuth2，如何以最传统的方式完成认证、授权。

“如何承载认证授权信息”这个问题的不同看法，代表了软件架构对待共享状态信息的两种不同思路：状态应该维护在服务端，抑或是在客户端之中？在分布式系统崛起以前，这个问题原本已是有了较为统一的结论的，以HTTP协议的Cookie-Session机制为代表的服务端状态存储在三十年来都是主流的解决方案。不过，到了最近十年，由于分布式系统中共享数据必然会受到CAP不兼容原理的打击限制，迫使人们重新去审视之前已基本放弃掉的客户端状态存储，这就让原本通常只在多方系统中采用的JWT令牌方案，在分布式系统中也有了另一块用武之地。本节的话题，也就围绕着Cookie-Session和JWT之间的相同与不同而展开。

## Cookie-Session

大家知道HTTP协议是一种无状态的传输协议，无状态是指协议对事务处理没有上下文的记忆能力，每一个请求都是完全独立的，但是我们中肯定有许多人并没有意识到HTTP协议无状态的重要性。假如你做了一个简单的网页，其中包含了1个HTML、2个Script脚本、3个CSS、还有10张图片，这个网页成功展示在用户屏幕前，需要完成16次与服务端的交互来获取上述资源，由于网络传输各种等因素的影响，服务器发送的顺序与客户端请求的先后并没有必然的联系，按照可能出现的响应顺序，理论上最多会有P(16,16) = 20,922,789,888,000种可能性。试想一下，如果HTTP协议不是设计成无状态的，这16次请求每一个都有依赖关联，先调用哪一个、先返回哪一个，都会对结果产生影响的话，那协调工作会有多么复杂。

可是，HTTP协议的无状态特性又有悖于我们最常见的网络应用场景，典型就是认证授权，系统总得要获知用户身份才能提供合适的服务，因此，我们也希望HTTP能有一种手段，让服务器至少有办法能够区分出发送请求的用户是谁。为了实现这个目的，[RFC 6265](https://tools.ietf.org/html/rfc6265#section-4.1)规范定义了HTTP的状态管理机制，在HTTP协议中增加了Set-Cookie指令，该指令的含义是以键值对的方式向客户端发送一组信息，此信息将在此后一段时间内的每次HTTP请求中，以名为Cookie的Header附带着重新发回给服务端，以便服务端区分来自不同客户端的请求。一个典型的Set-Cookie指令如下所示：

```http
Set-Cookie: id=icyfenix; Expires=Wed, 21 Feb 2020 07:28:00 GMT; Secure; HttpOnly
```

收到该指令以后，客户端再对同一个域的请求中就会自动附带有键值对信息`id=icyfenix`，譬如以下代码所示：

```http
GET /index.html HTTP/2.0
Host: icyfenix.cn
Cookie: id=icyfenix
```

根据每次请求传到服务端的Cookie，服务器就能分辨出请求来自于哪一个用户。由于Cookie是放在请求头上的，属于额外的传输负担，不应该携带过多的内容，而且放在Cookie中传输也并不安全，容易被中间人窃取或被篡改，所以通常是不会像例子中设置`id=icyfenix`这样的明文信息。一般来说，系统会把状态信息保存在服务端，在Cookie里只传输的是一个无字面意义的、不重复的字符串，习惯上以`sessionid`或者`jsessionid`为名，服务器拿这个字符串为Key，在内存中开辟一块空间，以Key/Entity的结构存储每一个在线用户的上下文状态，再辅以一些超时自动清理之类的管理措施。这种服务端的状态管理机制就是今天大家非常熟悉的Session，Cookie-Session也即最传统但今天依然广泛应用于大量系统中的，由服务端与客户端联动来完成的状态管理机制。

Cookie-Session方案在本章的主题“安全性”上其实是有一定先天优势的：状态信息都存储于服务器，只要依靠客户端的[同源策略](https://en.wikipedia.org/wiki/Same-origin_policy)和HTTPS的传输层安全，保证Cookie中的键值不被窃取而出现被冒认身份的情况，就能完全规避掉上下文信息在传输过程中被泄漏和篡改的风险。Cookie-Session方案的另一大优点是服务端有主动的状态管理能力，可根据自己的意愿随时修改、清除任意上下文信息，譬如很轻易就能实现强制某用户下线的这样功能。

Session-Cookie在单节点的单体服务环境中是最合适的方案，但当需要水平扩展服务能力，要部署集群时就开始面临麻烦了，由于Session存储在服务器的内存中，当服务器水平拓展成多节点时，设计者必须在以下三种方案中选择其一：

- 牺牲集群的一致性（Consistency），让均衡器采用亲和式的负载均衡算法，譬如根据用户IP或者Session来分配节点，每一个特定用户发出的所有请求都一直被分配到其中某一个节点来提供服务，每个节点都不重复地保存着一部分用户的状态，如果这个节点崩溃了，里面的用户状态便完全丢失。
- 牺牲集群的可用性（Availability），让各个节点之间采用复制式的Session，每一个节点中的Session变动都会发送到组播地址的其他服务器上，这样某个节点崩溃了，不会中断都某个用户的服务，但Session之间组播复制的同步代价高昂，节点越多时，同步成本越高。
- 牺牲集群的分区容忍性（Partition Tolerance），让普通的服务节点中不再保留状态，将上下文集中放在一个所有服务节点都能访问到的数据节点中进行存储。此时的矛盾是数据节点就成为了单点，一旦数据节点损坏或出现网络分区，整个集群都不再能提供服务。

通过前面章节的内容，我们已经知道只要在分布式系统中共享信息，CAP就不可兼得，所以分布式环境中的状态管理一定会受到CAP的局限，无论怎样都不可能完美。但如果只是解决分布式下的认证授权问题，并顺带解决少量状态的问题，就不一定只能依靠共享信息去实现。这句话的言外之意是提醒读者，接下来的JWT令牌与Cookie-Session并不是完全对等的解决方案，它只用来处理认证授权问题，充其量能携带少量非敏感的信息，只是Cookie-Session在认证授权问题上的替代品，而不能说JWT要比Cookie-Session更加先进，更不可能全面取代Cookie-Session机制。

## JWT

Cookie-Session机制在分布式环境下会遇到CAP不可兼得的问题，而在多方系统中，就更不可能谈什么Session层面的数据共享了，哪怕服务端之间能共享数据，客户端的Cookie也没法跨域。所以我们不得不重新捡起最初被抛弃的思路，当服务器存在多个，客户端只有一个时，把状态信息存储在客户端，每次随着请求发回服务器去。笔者才说过这样做的缺点是无法携带大量信息，而且有泄漏和篡改的安全风险。信息量受限的问题并没有太好的解决办法，但是要确保信息不被中间人篡改则还是可以实现的，JWT便是这个问题的标准答案。

JWT（JSON Web Token）定义于[RFC 7519](https://tools.ietf.org/html/rfc7519)标准之中，是目前广泛使用的一种令牌格式，尤其经常与OAuth2配合应用于分布式的、涉及多方的应用系统中。介绍JWT的具体构成之前，我们先来直观地看一下它是什么样子的，如图5-13所示。

:::center
![](./images/jwt.png)
图5-13 JWT令牌结构
:::

以上截图来自JWT官网（[https://jwt.io](https://jwt.io)），数据则是笔者随意编的。右边的JSON结构是JWT令牌中携带的信息，左边的字符串呈现了JWT令牌的本体。它最常见的使用方式是附在名为Authorization的Header发送给服务端，前缀在[RFC 6750](https://tools.ietf.org/html/rfc6750)中被规定为Bearer。如果你没有忘记“[认证方案](/architect-perspective/general-architecture/system-security/authentication.html#认证的标准)”与“[OAuth 2](/architect-perspective/general-architecture/system-security/authorization.html#oauth2)”的内容，那看到Authorization这个Header与Bearer这个前缀时，便应意识到它是HTTP认证框架中的OAuth 2认证方案。如下代码展示了一次采用JWT令牌的HTTP实际请求：

```http
GET /restful/products/1 HTTP/1.1
Host: icyfenix.cn
Connection: keep-alive
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJpY3lmZW5peCIsInNjb3BlIjpbIkFMTCJdLCJleHAiOjE1ODQ5NDg5NDcsImF1dGhvcml0aWVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwianRpIjoiOWQ3NzU4NmEtM2Y0Zi00Y2JiLTk5MjQtZmUyZjc3ZGZhMzNkIiwiY2xpZW50X2lkIjoiYm9va3N0b3JlX2Zyb250ZW5kIiwidXNlcm5hbWUiOiJpY3lmZW5peCJ9.539WMzbjv63wBtx4ytYYw_Fo1ECG_9vsgAn8bheflL8
```

图5-13中右边的状态信息是对令牌使用Base64URL转码后得到的明文，请特别注意是明文，JWT只解决防篡改的问题，并不解决防泄漏的问题，因此令牌默认是不加密的。尽管你自己要加密也并不难做到，接收时自行解密即可，但这样做其实没有太大意义，原因笔者将在下一节“[保密](/architect-perspective/general-architecture/system-security/confidentiality.html)”中去解释。

从明文中可以看到JWT令牌是以JSON结构（毕竟名字就叫JSON Web Token）存储的，结构总体上可划分为三个部分，每个部分间用点号`.`分隔开。

第一部分是**令牌头**（Header），内容如下所示：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

它描述了令牌的类型（统一为typ:JWT）以及令牌签名的算法，示例中HS256为HMAC SHA256算法的缩写，其他各种系统支持的签名算法可以参考https://jwt.io/网站所列。

:::quote 额外知识：散列消息认证码

在本节及后面其他关于安全的内容中，经常会在某种哈希算法前出现“HMAC”的前缀，这是指散列消息认证码（Hash-based Message Authentication Code，HMAC）。可以简单将它理解为一种带有密钥的哈希摘要算法，实现形式上通常是把密钥以加盐方式混入，与内容一起做哈希摘要。

HMAC哈希与普通哈希算法的差别是普通的哈希算法通过Hash函数结果易变性保证了原有内容未被篡改，HMAC不仅保证了内容未被篡改过，还保证了该哈希确实是由密钥的持有人所生成的。如图5-14所示。

:::center

![hmac](./images/hmac.png)

图5-14 HMAC哈希与普通哈希算法的差别

:::

令牌的第二部分是**负载**（Payload），这是令牌真正需要向服务端传递的信息。针对认证问题，负载至少应该包含能够告知服务端“这个用户是谁”的信息，针对授权问题，令牌至少应该包含能够告知服务端“这个用户拥有什么角色/权限”的信息。JWT的负载部分是可以完全自定义的，根据具体要解决的问题不同，设计自己所需要的信息，只是总容量不能太大，毕竟要受到HTTP Header大小的限制。一个JWT负载的例子如下所示：

```json
{
  "username": "icyfenix",
  "authorities": [
    "ROLE_USER",
    "ROLE_ADMIN"
  ],
  "scope": [
    "ALL"
  ],
  "exp": 1584948947,
  "jti": "9d77586a-3f4f-4cbb-9924-fe2f77dfa33d",
  "client_id": "bookstore_frontend"
}
```

而JWT在RFC 7519中推荐（非强制约束）了七项声明名称（Claim Name），如有需要用到这些内容，建议字段名与官方的保持一致：

- iss（Issuer）：签发人。
- exp（Expiration Time）：令牌过期时间。
- sub（Subject）：主题。
- aud （Audience）：令牌受众。
- nbf （Not Before）：令牌生效时间。
- iat （Issued At）：令牌签发时间。
- jti （JWT ID）：令牌编号。

此外在RFC 8225、RFC 8417、RFC 8485等规范文档，以及OpenID等协议中，都定义有约定好公有含义的名称，内容比较多，笔者就不贴出来了，可以参考[IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml)。

令牌的第三部分是**签名**（Signature），签名的意思是：使用在对象头中公开的特定签名算法，通过特定的密钥（Secret，由服务器进行保密，不能公开）对前面两部分内容进行加密计算，以例子里使用的JWT默认的HMAC SHA256算法为例，将通过以下公式产生签名值：

```java
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload) , secret)
```

签名的意义在于确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失任何信息。因为被签名的内容哪怕发生了一个字节的变动，也会导致整个签名发生显著变化。此外，由于签名这件事情只能由认证授权服务器完成（只有它知道Secret），任何人都无法在篡改后重新计算出合法的签名值，所以服务端才能够完全信任客户端传上来的JWT中的负载信息。

JWT默认的签名算法HMAC SHA256是一种带密钥的哈希摘要算法，加密与验证过程均只能由中心化的授权服务来提供，所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用。在多方系统或者授权服务与资源服务分离的分布式应用中，通常会采用非对称加密算法来进行签名，这时候除了授权服务端持有的可以用于签名的私钥外，还会对其他服务器公开一个公钥，公开方式一般遵循[JSON Web Key规范](https://tools.ietf.org/html/rfc7517)。公钥不能用来签名，但是能被其他服务用于验证签名是否由私钥所签发的。这样其他服务器也能不依赖授权服务器、无须远程通信即可独立判断JWT令牌中的信息的真伪。

在Fenix's Bookstore的单体服务版本中，采用了默认的HMAC SHA256算法来加密签名，而Istio服务网格版本里，终端用户认证会由服务网格的基础设施参来完成，此时就改用了非对称加密的RSA SHA256算法来进行签名，希望深入了解凭证安全的读者，不妨对比一下这两部分的代码。更多关于哈希摘要、对称和非对称加密的讨论，将会在“[传输](/architect-perspective/general-architecture/system-security/transport-security.html)”一节中继续进行。

JWT令牌是多方系统中一种优秀的凭证载体，它不需要任何一个服务节点保留任何一点状态信息，就能够保障认证服务与用户之间的承诺是双方当时真实意图的体现，是准确、完整、不可篡改、且不可抵赖的。同时，由于JWT本身可以携带少量信息，这十分有利于RESTful API的设计，能够较容易地做成无状态服务，在做水平扩展时就不需要像前面Cookie-Session方案那样考虑如何部署的问题。现实中也确实有一些项目直接采用JWT来承载上下文来实现完全无状态的服务端，这能获得任意加入或移除服务节点的巨大便利，天然具有完美的水平扩缩能力。譬如，在调试Fenix's Bookstore的代码时，你随时都可以重启服务，重启后，客户端仍然能毫无感知地继续操作流程；而对于有状态的系统，就必须通过重新登录、进行前置业务操作来为服务端重建状态。尽管大型系统中只使用JWT来维护上下文状态，服务端完全不持有状态是不太现实的，不过将热点的服务单独抽离出来做成无状态，仍是一种有效提升系统吞吐能力的架构技巧。但是，JWT也并非没有缺点的完美方案，它存在着以下几个经常被提及的缺点：

- **令牌难以主动失效**：JWT令牌一旦签发，理论上就和认证服务器再没有什么瓜葛了，在到期之前就会始终有效，除非服务器部署额外的逻辑去处理失效问题，这对某些管理功能的实现是很不利的。譬如一种颇为常见的需求是：要求一个用户只能在一台设备上登录，在B设备登录后，之前已经登录过的A设备就应该自动退出。如果采用JWT，就必须设计一个“黑名单”的额外的逻辑，用来把要主动失效的令牌集中存储起来，而无论这个黑名单是实现在Session、Redis或者数据库中，都会让服务退化成有状态服务，降低了JWT本身的价值，但黑名单在使用JWT时依然是很常见的做法，需要维护的黑名单一般是很小的状态量，许多场景中还是有存在价值的。
- **相对更容易遭受重放攻击**：首先说明Cookie-Session也是有重放攻击问题的，只是因为Session中的数据控制在服务端手上，应对重放攻击会相对主动一些。要在JWT层面解决重放攻击需要付出比较大的代价，无论是加入全局序列号（HTTPS协议的思路）、Nonce字符串（HTTP Digest验证的思路）、挑战应答码（当下网银动态令牌的思路）、还是缩短令牌有效期强制频繁刷新令牌，在真正应用起来时都很麻烦。真要处理重放攻击，建议的解决方案是在信道层次（譬如启用HTTPS）上解决，而不提倡在服务层次（譬如在令牌或接口其他参数上增加额外逻辑）上解决。
- **只能携带相当有限的数据**：HTTP协议并没有强制约束Header的最大长度，但是，各种服务器、浏览器都会有自己的约束，譬如Tomcat就要求Header最大不超过8KB，而在Nginx中则默认为4KB，因此在令牌中存储过多的数据不仅耗费传输带宽，还有额外的出错风险。
- **必须考虑令牌在客户端如何存储**：严谨地说，这个并不是JWT的问题而是系统设计的问题。如果授权之后，操作完关掉浏览器就结束了，那把令牌放到内存里面，压根不考虑持久化那是最理想的方案。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登录的。这样的话，想想客户端该把令牌存放到哪里？Cookie？localStorage？Indexed DB？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充用户的身份做任何事情。
- **无状态也不总是好的**：这个其实不也是JWT的问题。如果不能想像无状态会有什么不好的话，我给你提个需求：请基于无状态JWT的方案，做一个在线用户实时统计功能。兄弟，难搞哦。
